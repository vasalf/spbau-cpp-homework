Задание №15
===========

Мотивация
---------

__Этот раздел не требуется читать для понимания условия задания__.

Предположим, что у нас есть какая-то задача обработки списков/векторов/массивов.
Например, такая: имеется `vector<pair<int, string>> pages`, который содержит
любимые страницы пользователя. Первый элемент в паре - сколько раз эта страница
была посещена, второй - её адрес. Нам требуется получить адреса всех страниц,
которые никогда не посещались, и адреса которых начинаются с `https://vk.com/`.
На языке C++ эту задачу можно было бы решить так:

~~~
vector<string> result;
for (auto &page : pages) {
  if (page.first == 0 && page.second.find("https://vk.com/") == 0) {
    result.push_back(page.second);
  }
}}
~~~
К сожалению, это решение занимает довольно много места, а смысл оказывается
заключён в одной строчке с `if`.

В некоторых языках программирования в той или иной степени присутствуют
декларативные способы обработки данных, позволяющие записать подобные
манипуляции намного короче. Например:

~~~
# Python
[ addr
  for (cnt, addr) in pages
  if cnt == 0 and addr.startswith("https://vk.com/") ]
  
# SQL
SELECT addr
FROM pages
WHERE cnt = 0 AND addr LIKE 'https://vk.com/%'

# Встроенный в C# язык LINQ:
from page in pages
where (page.Item1 == 0) && (page.Item2.StartsWith("https://vk.com/"))
select page.Item2

# Java 8
pages.stream().where((page) -> page.cnt == 0)
              .where((page) -> page.addr.startsWith("https://vk.com/"))
			  .map((page) -> page.addr)
			  .toList()
~~~

В этом задании вам потребуется реализовать похожий функционал в C++.
Цель - записывать несложные преобразования списков короче, чем циклами `for`,
и без использования дополнительных переменных.

Общее
-----

Вам требуется реализовать библиотеку из нескольких классов и функций, которая
бы позволила обрабатывать последовательные данные в одну несложную команду,
похожую по синтаксису на LINQ и по духу - на потоки Java 8.

__Пример 1__:

~~~
int xs[] = { 1, 2, 3, 4, 5 };
std::vector<int> res =
  from(xs, xs + 5)  // Взять элементы xs
  .select([](int x) { return x * x; })  // Возвести в квадрат
  .where_neq(25)    // Оставить только значения != 25
  .where([](int x) { return x > 3; })   // Оставить только значения > 3
  .drop(2)          // Убрать два элемента из начала
  .to_vector();     // Преобразовать результат в вектор
~~~

__Пример 2__:

~~~
std::istream_iterator<int> in(std::cin), eof;
std::cout <<
  from(in, eof)  // Взять числа из входного потока
  .take(4)       // Не более четырёх чисел
  .until_eq(-1)  // Перестать читать после прочтения -1
  .to_vector();  // Получить список считанных чисел
~~~

__Пример 3__:
~~~
int xs[] = { 1, 2, 3, 4, 5 };
std::vector<double> res =
  from(xs, xs + 5)  // Взять элементы xs
  .select<double>([](int x) { return sqrt(x); })  // Извлечь корень
  .to_vector();     // Преобразовать результат в вектор
~~~

__Пример 4__:
~~~
std::istream_iterator<int> in(std::cin), eof;
std::ostream_iterator<double> out(std::cout, "\n");
from(in, eof)    // Взять числа из входного потока
.select([](int x) { return sqrt(x); })  // Извлечь из каждого корень
.copy_to(out);  // Вывести на экран
~~~

Идеологически мы составляем цепочку команд (как `echo | foo` в Bash), по которой
лениво передаются элементы.

При этом:
* Цепочка состоит из трёх принципиальных частей: одна команда генерации
  последовательности, ноль или более команд преобразований, одна завершающая
  команда (подробнее ниже).
* Пользователю библиотеки не разрешается разделять вычисление на несколько
  команд, всё должно быть сделано "от одной точки с запятой до следующей".
* В процессе вычислений могут использоваться произвольные копируемые типы.
  См. пример 3 - там `int` преобразуется в `double` командой `select`.
* В качестве входа (функция `from`) могут использоваться произвольные
  STL-подобные итераторы и контейнеры, а также массивы.
* Вычисления должны производиться максимально "лениво". Эталон ленивости -
  Haskell. Например, после запуска второго примера из входного потока должно
  быть считано не более четырёх чисел. А при запуске четвёртого примера
  результаты вычислений должны появляться на экране интерактивно, как только
  пользователь вводит числа.
* Все детали реализации и названия внутренних классов полностью должны быть
  скрыты от пользователя (должно получиться автоматически - никаких
  переменных с вашими классами пользователь создавать не должен).
* Командам, кроме `to_vector`, запрещается сохранять в себе все прошедшие
  через них элементы (иногда хотя бы один сохранять придётся).

Должны поддерживаться следующие команды:
1. Генерация последовательностей:
  * `template<typename T> ??? from(T begin, T end)` - генерирует
    последовательность из STL-полуинтервала `[begin; end)`.

  Во всех трёх случаях исходный контейнер не должен изменяться никаким образом.
2. Преобразования последовательностей:
  * `.drop(count)` - удаляет из последовательности первые `count` элементов.
  * `.take(count)` - оставляет в последовательности только первые `count`
    элементов. В частности, из-за ленивости элемент `count+1` никогда не должны
	быть запрошен у генератора последовательности.
  * `.select(f)` - применяет функцию `f` к каждом элементу последовательности.
    `f` может изменять тип элемента - в таком случае требуется
	явное указание нового типа синтаксисом `.select<T>(f)` (как в примере 3).
	Вообще говоря, можно решить и без этого при помощи `std::result_of`, но мы
	не будем.
  * `.until(f)` - обрывает последовательность, как только встретит элемент,
    удовлетворяющий предикату `f`. В частности, из-за ленивости все последующие
	элементы никогда не должны спрашиваться у предыдущих команд.
  * `.until_eq(v)` обрывает последовательность, как только встретит элемент,
    равный `v`.
  * `.where(f)` - оставляет в последовательности только те элементы, которые
    удовлетворяют предикату `f`. `f` - это произвольный функциональный
	объект (функция, функтор, лямбда).
  * `.where_neq(v)` - оставляет в последовательность только элементы, не равные
    `v`.
3. Терминальные команды:
  * `.to_vector()` - собирает все элементы в вектор и возвращает его.
  * `.copy_to(iter)` - копирует сгенерированную последовательность в
    STL-подобный итератор `iter` (аналогично алгоритму `std::copy`).
	Например, это может быть `ostream_iterator` (пример 4),
	`back_inserter` или обычный итератор (если мы заранее знаем количество
	элементов).

Реализация
----------

Ниже мы предлагаем вам структуру решения. Если вам хочется сделать совсем
по-другому или что-то кажется нелогичным - обсудите это с вашим преподавателем.

* Генерирующие команды - это функции, возвращающие некоторые
  классы (которые мы назовём "энумераторами"), которые как-то описывают
  сгенерированную последовательность.
* Каждый энумератор имеет полный набор методов для преобразовывающих и
  терминальных команд. Каждый такой метод возвращает новый энумератор.
* Так как все вызовы этих методов будут скомбинированы пользователем в рамках
  одного statement, мы можем не беспокоиться за время жизни и владение
  энумераторами и просто передавать их по значению/ссылкам - компилятор
  уничтожит временные объекты только после того, как вся цепочка отработает.
* Имеет смысл включить C++14, чтобы получить возможность писать `auto` вместо
  возвращаемых типов у функции.
* Имеет смысл сделать базовый класс "энумератор", чтобы избежать дублирования
  кода для `.where`/`.select`/`.copy_to` в разных энумераторах.
* Несмотря на то, что задание можно реализовать целиком на шаблонах (и даже
  без дублирования кода), с виртуальными функциями решение будет несколько
  проще.
* Требуется по возможности избегать лишних копирований и лишних перемещений,
  не особо надеясь на догадливость оптимизатора.
* Требуется не сохранять объекты без необходимости - указатели или ссылки
  лучше (но помним про стандартные проблемы с ними).
* Запрещается вызывать предикат (для `.where` и пр.)/функцию трансформации
  (для `.select`) на одном элементе последовательности более одного раза.
  Считайте, что это очень дорогая операция, количество которых должно быть
  минимально.
* Мы предлагаем сделать интерфейс энумератора похожим на интерфейс итератора:
  * В любой момент энумератор либо указывает на какой-то определённый элемент,
    либо находится в состоянии "конец последовательности".
  * Проверить существование текущего элемента можно при помощи оператора `bool`.
  * Энумератор можно сдвинуть на следующий элемент оператором `++`. Заметьте,
    что в энумераторе для `.where()` такая операция может потребовать более,
	чем один сдвиг предыдущего в цепочке.
  * Получить константную ссылку на текущий элемент можно при помощи оператора
    `*`. Будет удобнее, если гарантируется, что вызов этого оператора не сделает
	ничего, кроме возврата ссылки (в частности, не будет двигать предыдущие
	энумераторы) - так поведение будет похоже на поведение `istream_iterator`.
* Настоятельно рекомендуется писать юнит-тесты для своей библиотеки.
* Настоятельно рекомендуется реализовывать группу методов `where_*` через
  `where` и лямбды. Аналогично для `until_*`.
* Для хранения функциональных объектов можно как использовать `std::function`,
  так и параметризовывать свои классы типом функционального объекта. Первый
  подход проще, но влечёт ещё один виртуальный вызов и динамическое
  выделение памяти. Второй подход не требует ни того, ни другого, но
  необязателен.
	
Предлагаемая заглушка для базового класса "энумератор" (в ней может не хватать
каких-то важных слов):

~~~
template<typename T>
class enumerator {
public:
  T operator*(); // Получает текущий элемент.
  ??? operator++();  // Переход к следующему элементу
  operator bool();  // Возвращает true, если есть текущий элемент
}
~~~

Предоставленный скелет
----------------------

Вы можете найти авторское решение с некоторыми удалёнными строками и словами
в файле `linq.h`. Там уже частично реализованы:

* `class enumerator` - вам требуется придумать корректную сигнатуру для
  первых трёх методов, реализовать уже написанные методы (у них сигнатура
  корректна) и дописать недостающие по аналогии.
* `class range_enumerator` - энумератор по STL-подобному полуинтервалу из
  двух итераторов. Дополнительные поля в этом классе (кроме `begin_` и
  `end_`) не требуются.
* Функция `from` - обёртка для удобного создания `range_enumerator`, в её
  реализации не хватает лишь шаблонных типов для `range_enumerator`.
* `class drop_enumerator` - заглушка для энумератора, получающегося из операции
  `.drop()`. `take` реализуется аналогично. Возможно, вам потребуется добавить
  объявления полей.
* `class select_enumerator` - заглушка для энумератора, получающегося из
  операции `.select()`.
* `class until_enumerator` - заглушка для энумератора, получающегося из операции
  `.until()`. Операция `.where()` должна получиться аналогично.
* Все конструкторы уже имеют удобную сигнатуру.
  
Разбор примера
--------------

Возьмём пример 4:
~~~
std::ostream_iterator<double> out(std::cout, "\n");
from(in, eof)    // Взять числа из входного потока
.select([](int x) { return sqrt(x); })  // Извлечь из каждого корень
.copy_to(out);  // Вывести на экран
~~~

В вашей реализации может происходить следующее:
1. `from()` возвращает энумератор `range_enumerator` (назовём его `A`), который
  соответствует  итераторам `in` и `eof`. Когда у `A` запрашивают элемент,
  он переадресует этот вопрос итератору `in`.
2. Метод `range_enumerator::select()` возвращает `select_enumerator` (назовём
  его `B`), который при необходимости запрашивает элементы у `A`, извлекает
  корень, и подаёт на свой выход.
3. Метод `select_enumerator::copy_to()` не возвращает ничего, но начинает
  запрашивать у `B` элементы по одному и, как только удаётся получить очередной
  элемент, записывает его в итератор `out`.
4. Несмотря на то, что энумераторы `A` и `B` - временные объекты, они живут до
  тех пор, пока `copy_to` не закончит выполнение. В частности, они могут
  хранить друг на друга ссылки и не беспокоиться о выделении памяти.

Ограничения и тестирование
--------------------------

* В вашем репозитории должна появиться папка с названием `lab_15` и следующей
  структурой внутри:
  
  ~~~
  <корень-репозитория>
  +-- lab_15
      +-- include
          +-- linq.h
  ~~~
  
  При этом:
  * Компиляция при тестировании будет производиться GCC с ключом `-std=c++14`.
  * Файл `linq.h` должен быть самодостаточен и не требовать никаких других
    файлов для компиляции и работы.
  * В папке `lab_15` могут быть и другие произвольные файлы.
  
* Вам предоставлен файл `smoke_test.cpp` для _неполной_ проверки корректности
  решения. Если расположить его в папке `lab_15`, то следующая команда,
  запущенная из папки `lab_15`, должна завершиться успешно, если решение 
  правильное:
  
  ~~~
  g++ -std=c++14 -pedantic -Wall -Wextra -Werror smoke_test.cpp -Iinclude -o smoke_test && ./smoke_test && echo OK
  ~~~
  
  Обратите внимание, что набор тестов _неполный_ и вам рекомендуется также
  написать свои.
  
* Также вам предоставлена урезанная версия `smoke_test.cpp` - 
  `minimal_smoke_test.cpp`. Для получения ненулевого количества баллов
  требуется, чтобы этот файл компилировался и успешно выполнялся.

* Дедлайн сдачи - 28 мая, 23:59. До этого момента ваше решение должно быть
  закоммичено в SVN. Возможно, ваш преподаватель будет готов проверить ваше
  решение раньше или даже несколько раз - напишите ему с таким вопросом,
  если станет актуально.
  
Система оценки
--------------

Если структура папок в вашем репозитории не соответствует заданию или файл
`minimal_smoke_compile.cpp` не компилируется, то вы автоматически получаете 0
баллов. Вывод компилятора вам будет предоставлен. Дальнейшая проверка будет
производиться только после исправления ошибок компиляции и структуры папок.

Баллы распределяются так:
* От 0 до 2 баллов - за компилирующийся с `minimal_smoke_test.cpp` код:
  * 1 балл, если компилируется и почти работает ("почти" на усмотрение
    преподавателя).
  * 2 балла, если компилируется и корректно работает.
* От 0 до 5 баллов - за корректность.
* От 0 до 3 баллов - за стиль кода.
